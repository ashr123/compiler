#use "code-gen.ml";;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics (Tag_Parser.tag_parse_expressions (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  [("boolean?", "is_boolean"); ("float?", "is_float"); ("integer?", "is_integer"); ("pair?", "is_pair");
   ("null?", "is_null"); ("char?", "is_char"); ("vector?", "is_vector"); ("string?", "is_string");
   ("procedure?", "is_procedure"); ("symbol?", "is_symbol"); ("string-length", "string_length");
   ("string-ref", "string_ref"); ("string-set!", "string_set"); ("make-string", "make_string");
   ("vector-length", "vector_length"); ("vector-ref", "vector_ref"); ("vector-set!", "vector_set");
   ("make-vector", "make_vector"); ("symbol->string", "symbol_to_string"); ("char->integer", "char_to_integer");
   ("integer->char", "integer_to_char"); ("eq?", "is_eq"); ("+", "bin_add"); ("*", "bin_mul");
   ("-", "bin_sub"); ("/", "bin_div"); ("<", "bin_lt"); ("=", "bin_equ"); ("car", "get_car"); ("cdr", "get_cdr");
   ("cons", "make_pair"); ("set-car!", "set_car"); ("set-cdr!", "set_cdr")
  (* you can add yours here *)];;

let make_prologue consts_tbl fvars_tbl =
  let get_const_address c = 
    let const_row = List.find (fun (const, _, _) ->
        let matcher = (fun const c ->
            match const, c with
            | Void, Void -> true
            | Sexpr s1, Sexpr s2 -> sexpr_eq s1 s2
            | _ -> false) in
        matcher const c) consts_tbl in
    "const_tbl + " ^ string_of_int ((fun (_, offset, _) -> offset) const_row) in
  let get_fvar_address const =
    let fvar = List.find (fun (st, _) -> st = const) fvars_tbl in
    "fvar_tbl + " ^ string_of_int ((fun (_, offset) -> offset) fvar) in
  let make_primitive_closure (prim, label) =
    "\tMAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
\tmov [" ^ (get_fvar_address prim)  ^ " * WORD_SIZE], rax" in
  let make_constant (c, a, s) = s in

  ";;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
\tresq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "\tdq T_UNDEFINED") fvars_tbl)) ^ "

global main
section .text
main:
\t;; set up the heap
\tmov rdi, GB(4)
\tcall malloc
\tmov [malloc_pointer], rax

\t;; Set up the dummy activation frame
\t;; The dummy return address is T_UNDEFINED
\t;; (which a is a macro for 0) so that returning
\t;; from the top level (which SHOULD NOT HAPPEN
\t;; AND IS A BUG) will cause a segfault.
\tpush 0
\tpush qword SOB_NIL_ADDRESS
\tpush qword T_UNDEFINED
\tpush rsp

\tmov rbp, rsp
\tcall code_fragment
\tadd rsp, 4 * 8
\tret

code_fragment:
\t;; Set up the primitive stdlib fvars:
\t;; Since the primtive procedures are defined in assembly,
\t;; they are not generated by scheme (define ...) expressions.
\t;; This is where we emulate the missing (define ...) expressions
\t;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "

";;

(* let epilogue = raise X_this_should_not_happen;; *)

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts
  and fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl 0 in
  let code_fragment = "break:\n" ^ String.concat "\n"
      (List.map
         (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void\n")
         asts) in
  let provided_primitives = file_to_string "prims.s" in

  print_string ((make_prologue consts_tbl fvars_tbl) ^
                code_fragment ^ "\n" ^
                provided_primitives ^ "\n" (* ^ epilogue *))

with Invalid_argument(x) -> raise X_missing_input_file;;